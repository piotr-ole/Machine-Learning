# precision at k
rows <- order(pred, decreasing = TRUE)
cl <- testSet[rows, class_index]
cl <- cl[1:floor(prec_k * length(cl))]
pred_prec <- sort(pred, decreasing = TRUE)[1:floor(prec_k * length(pred))]
predicted_prec <- ifelse(pred > treshold, 1 , 0)
t2 <- table(predicted, true = cl)
# Other metrics
predicted <- ifelse(pred > treshold, 1 , 0)
t <- table(predicted, true = testSet[, class_index])
if (dim(t)[1] == 2) {
acc <- sum(diag(t)) / sum(t)
recall <- t[2, 2] / sum(t[ , 2])
precision <- t[2, 2] / sum(t[2 , ])
fpr <- t[2, 1] / sum(t[, 1])
precision_at_k <- t2[2, 2] / sum(t2[2 , ])
}
else if (sum(predicted) == 0) {
acc <- t[1] / sum(t)
recall <- 0
precision <- 0
fpr <- 0
precision_at_k <- 0
}
else {
acc <- t[2] / sum(t)
recall <- 1
precision <- t[2] / sum(t)
fpr <- 1
precision_at_k <- t[2] / sum(t)
}
return(list(table = t, accuracy = acc, recall = recall, precision = precision, precision_at_k = precision_at_k,
fpr = fpr))
}
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- seq(y)
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
}
plot(x,y)
}
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- seq(y)
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
}
return(x,y)
}
ROC(model.glm, test, 1, type = 'glm')
# calculates metrics after model evaluation on training set
# recall == tpr
metrics <- function(model, testSet, class_index, type, treshold = 0.5, prec_k = 0.1) {
if (type == 'glm') {
pred = predict(model, newdata = testSet, type = 'response')
}
else if (type == 'rpart') {
pred = predict(model, newdata = testSet, type = 'prob')[, 2]
}
# precision at k
rows <- order(pred, decreasing = TRUE)
cl <- testSet[rows, class_index]
cl <- cl[1:floor(prec_k * length(cl))]
pred_prec <- sort(pred, decreasing = TRUE)[1:floor(prec_k * length(pred))]
predicted_prec <- ifelse(pred_prec > treshold, 1 , 0)
t2 <- table(predicted_prec, true = cl)
# Other metrics
predicted <- ifelse(pred > treshold, 1 , 0)
t <- table(predicted, true = testSet[, class_index])
if (dim(t)[1] == 2) {
acc <- sum(diag(t)) / sum(t)
recall <- t[2, 2] / sum(t[ , 2])
precision <- t[2, 2] / sum(t[2 , ])
fpr <- t[2, 1] / sum(t[, 1])
precision_at_k <- t2[2, 2] / sum(t2[2 , ])
}
else if (sum(predicted) == 0) {
acc <- t[1] / sum(t)
recall <- 0
precision <- 0
fpr <- 0
precision_at_k <- 0
}
else {
acc <- t[2] / sum(t)
recall <- 1
precision <- t[2] / sum(t)
fpr <- 1
precision_at_k <- t[2] / sum(t)
}
return(list(table = t, accuracy = acc, recall = recall, precision = precision, precision_at_k = precision_at_k,
fpr = fpr))
}
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- seq(y)
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
}
return(x,y)
}
ROC(model.glm, test, 1, type = 'glm')
metrics(model.glm, test, 1, type = 'glm', treshold = 0)
metrics(model.glm, test, 1, type = 'glm', treshold = 1)
metrics(model.glm, test, 1, type = 'glm', treshold = 0.97)
metrics(model.glm, test, 1, type = 'glm', treshold = 0.01)
metrics(model.glm, test, 1, type = 'glm', treshold = 0.97)
metrics(model.glm, test, 1, type = 'glm', treshold = 0)
# calculates metrics after model evaluation on training set
# recall == tpr
metrics <- function(model, testSet, class_index, type, treshold = 0.5, prec_k = 0.1) {
if (type == 'glm') {
pred = predict(model, newdata = testSet, type = 'response')
}
else if (type == 'rpart') {
pred = predict(model, newdata = testSet, type = 'prob')[, 2]
}
# precision at k
rows <- order(pred, decreasing = TRUE)
cl <- testSet[rows, class_index]
cl <- cl[1:floor(prec_k * length(cl))]
pred_prec <- sort(pred, decreasing = TRUE)[1:floor(prec_k * length(pred))]
predicted_prec <- ifelse(pred_prec > treshold, 1 , 0)
t2 <- table(predicted_prec, true = cl)
# Other metrics
predicted <- ifelse(pred > treshold, 1 , 0)
t <- table(predicted, true = testSet[, class_index])
print(t)
if (dim(t)[1] == 2) {
acc <- sum(diag(t)) / sum(t)
recall <- t[2, 2] / sum(t[ , 2])
precision <- t[2, 2] / sum(t[2 , ])
fpr <- t[2, 1] / sum(t[, 1])
precision_at_k <- t2[2, 2] / sum(t2[2 , ])
}
else if (sum(predicted) == 0) {
acc <- t[1] / sum(t)
recall <- 0
precision <- 0
fpr <- 0
precision_at_k <- 0
}
else {
acc <- t[2] / sum(t)
recall <- 1
precision <- t[2] / sum(t)
fpr <- 1
precision_at_k <- t[2] / sum(t)
}
return(list(table = t, accuracy = acc, recall = recall, precision = precision, precision_at_k = precision_at_k,
fpr = fpr))
}
metrics(model.glm, test, 1, type = 'glm', treshold = 0.01)
metrics(model.glm, test, 1, type = 'glm', treshold = 0.01)
# calculates metrics after model evaluation on training set
# recall == tpr
metrics <- function(model, testSet, class_index, type, treshold = 0.5, prec_k = 0.1) {
if (type == 'glm') {
pred = predict(model, newdata = testSet, type = 'response')
}
else if (type == 'rpart') {
pred = predict(model, newdata = testSet, type = 'prob')[, 2]
}
# precision at k
rows <- order(pred, decreasing = TRUE)
cl <- testSet[rows, class_index]
cl <- cl[1:floor(prec_k * length(cl))]
pred_prec <- sort(pred, decreasing = TRUE)[1:floor(prec_k * length(pred))]
predicted_prec <- ifelse(pred_prec > treshold, 1 , 0)
t2 <- table(predicted_prec, true = cl)
# Other metrics
predicted <- ifelse(pred > treshold, 1 , 0)
t <- table(predicted, true = testSet[, class_index])
print(t)
print(t2)
if (dim(t)[1] == 2) {
acc <- sum(diag(t)) / sum(t)
recall <- t[2, 2] / sum(t[ , 2])
precision <- t[2, 2] / sum(t[2 , ])
fpr <- t[2, 1] / sum(t[, 1])
precision_at_k <- t2[2, 2] / sum(t2[2 , ])
}
else if (sum(predicted) == 0) {
acc <- t[1] / sum(t)
recall <- 0
precision <- 0
fpr <- 0
precision_at_k <- 0
}
else {
acc <- t[2] / sum(t)
recall <- 1
precision <- t[2] / sum(t)
fpr <- 1
precision_at_k <- t[2] / sum(t)
}
return(list(table = t, accuracy = acc, recall = recall, precision = precision, precision_at_k = precision_at_k,
fpr = fpr))
}
metrics(model.glm, test, 1, type = 'glm', treshold = 0.01)
# calculates metrics after model evaluation on training set
# recall == tpr
metrics <- function(model, testSet, class_index, type, treshold = 0.5) {
if (type == 'glm') {
pred = predict(model, newdata = testSet, type = 'response')
}
else if (type == 'rpart') {
pred = predict(model, newdata = testSet, type = 'prob')[, 2]
}
# Other metrics
predicted <- ifelse(pred > treshold, 1 , 0)
t <- table(predicted, true = testSet[, class_index])
if (dim(t)[1] == 2) {
acc <- sum(diag(t)) / sum(t)
recall <- t[2, 2] / sum(t[ , 2])
precision <- t[2, 2] / sum(t[2 , ])
fpr <- t[2, 1] / sum(t[, 1])
}
else if (sum(predicted) == 0) {
acc <- t[1] / sum(t)
recall <- 0
precision <- 0
fpr <- 0
}
else {
acc <- t[2] / sum(t)
recall <- 1
precision <- t[2] / sum(t)
fpr <- 1
}
return(list(table = t, accuracy = acc, recall = recall, precision = precision, fpr = fpr))
}
metrics(model.glm, test, 1, type = 'glm', treshold = 0.01)
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- seq(y)
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
}
return(x,y)
}
ROC(model.glm, test, 1, type = 'glm')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- seq(y)
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
}
plot(x,y)
}
ROC(model.glm, test, 1, type = 'glm')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
plot(x,y)
}
ROC(model.glm, test, 1, type = 'glm')
require(ggplot2)
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line()
}
ROC(model.glm, test, 1, type = 'glm')
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red')
}
ROC(model.glm, test, 1, type = 'glm')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_blank())
}
ROC(model.glm, test, 1, type = 'glm')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_blank(),
panel.grid = element_line(),
plot.title = element_text(hjust = 0.5))
}
ROC(model.glm, test, 1, type = 'glm')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_blank(),
panel.grid = element_line(col = 'black'),
plot.title = element_text(hjust = 0.5))
}
ROC(model.glm, test, 1, type = 'glm')
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_rect(col = 'white'),
panel.grid = element_line(),
plot.title = element_text(hjust = 0.5))
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_rect(col = 'white'),
panel.grid = element_line(),
plot.title = element_text(hjust = 0.5))
}
ROC(model.glm, test, 1, type = 'glm')
?panel.background
??panel.background
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_rect(fill = 'transparent'),
panel.grid = element_line(),
plot.title = element_text(hjust = 0.5))
}
ROC(model.glm, test, 1, type = 'glm')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 2, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_rect(fill = 'transparent'),
panel.grid = element_line(color = 'black'),
plot.title = element_text(hjust = 0.5))
}
ROC(model.glm, test, 1, type = 'glm')
ROC <- function(model, testSet, class_index, type) {
n <- 100
x <- numeric(n)
y <- numeric(n)
tresholds <- seq(0, 1, length.out = n)
i <- 1
for ( tresh in tresholds) {
m <- metrics(model.glm, test, 1, type = 'glm', treshold = tresh)
x[i] <- m$fpr
y[i] <- m$recall
i <- i + 1
}
df <- data.frame(x = x , y = y)
ggplot(data = df, aes(x = x , y = y)) + geom_line(size = 1.5, col = 'red') +
ggtitle('ROC Curve') +
xlab('FPR') +
ylab('TPR') +
theme(panel.background = element_rect(fill = 'transparent'),
panel.grid = element_line(color = '#d9d9d9'),
plot.title = element_text(hjust = 0.5))
}
ROC(model.glm, test, 1, type = 'glm')
prec_at_k <- function(model, testSet, class_index, type,  prec_k = 0.1) {
if (type == 'glm') {
pred = predict(model, newdata = testSet, type = 'response')
}
else if (type == 'rpart') {
pred = predict(model, newdata = testSet, type = 'prob')[, 2]
}
# precision at k
rows <- order(pred, decreasing = TRUE)
cl <- testSet[rows, class_index]
cl <- cl[1:floor(prec_k * length(cl))]
pred_prec <- sort(pred, decreasing = TRUE)[1:floor(prec_k * length(pred))]
predicted_prec <- ifelse(pred_prec > treshold, 1 , 0)
t2 <- table(predicted_prec, true = cl)
precision_at_k <- t2[2, 2] / sum(t2[2 , ])
return(precision_at_k)
}
ROC(model = model.rpart, testSet = test, class_index = 1, type = 'rpart')
ROC(model = model.glm, testSet = test, class_index = 1, type = 'rpart')
setwd("C:/Users/piotr/Desktop/Github- projects/Machine-Learning/Laboratoria ZMUM/Ensembles")
setwd("C:/Users/piotr/Desktop/Github- projects/Machine-Learning/Laboratoria ZMUM/Ensembles")
rm(list = ls())
source('../Functions/functions.R')
require(rpart)
require(rpart.plot)
