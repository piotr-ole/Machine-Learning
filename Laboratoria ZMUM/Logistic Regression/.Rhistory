all[10]
all[11]
all <- html_text(html_nodes(loty, "p"))
all[1]
all[2]
all[3]
all[4]
all[5]
all[6]
all <- html_text(html_nodes(loty, "p"))
l <- strsplit(all[1], " ")
l <- unlist(l)
l <- l[(l != "") & (l != "\n")]
l
d <- data.frame()
d <- rbind(l)
d <- as.data.frame(d)
d <-d[c(-2, -3)]
d
loty <- read_html("http://www.azair.eu/azfin.php?searchtype=flexi&tp=0&isOneway=return&srcAirport=Wroclaw+%5BWRO%5D+%28%2BPOZ%2CKTW%2CPRG%2CKRK%29&srcap1=POZ&srcap2=KTW&srcap5=PRG&srcap9=KRK&srcFreeAirport=&srcTypedText=pra&srcFreeTypedText=&srcMC=&dstAirport=Milan+%5BMXP%5D+%28%2BLIN%2CBGY%29&dstap0=LIN&dstap1=BGY&dstFreeAirport=&dstTypedText=mil&dstFreeTypedText=&dstMC=MIL_ALL&depmonth=201903&depdate=2019-03-20&aid=0&arrmonth=202003&arrdate=2020-03-19&minDaysStay=5&maxDaysStay=8&dep0=true&dep1=true&dep2=true&dep3=true&dep4=true&dep5=true&dep6=true&arr0=true&arr1=true&arr2=true&arr3=true&arr4=true&arr5=true&arr6=true&samedep=true&samearr=true&minHourStay=0%3A45&maxHourStay=23%3A20&minHourOutbound=0%3A00&maxHourOutbound=24%3A00&minHourInbound=0%3A00&maxHourInbound=24%3A00&autoprice=true&adults=1&children=0&infants=0&maxChng=1&currency=EUR&indexSubmit=Search")
#wczytanie danych
library(rvest)
loty <- read_html("http://www.azair.eu/azfin.php?searchtype=flexi&tp=0&isOneway=return&srcAirport=Wroclaw+%5BWRO%5D+%28%2BPOZ%2CKTW%2CPRG%2CKRK%29&srcap1=POZ&srcap2=KTW&srcap5=PRG&srcap9=KRK&srcFreeAirport=&srcTypedText=pra&srcFreeTypedText=&srcMC=&dstAirport=Milan+%5BMXP%5D+%28%2BLIN%2CBGY%29&dstap0=LIN&dstap1=BGY&dstFreeAirport=&dstTypedText=mil&dstFreeTypedText=&dstMC=MIL_ALL&depmonth=201903&depdate=2019-03-20&aid=0&arrmonth=202003&arrdate=2020-03-19&minDaysStay=5&maxDaysStay=8&dep0=true&dep1=true&dep2=true&dep3=true&dep4=true&dep5=true&dep6=true&arr0=true&arr1=true&arr2=true&arr3=true&arr4=true&arr5=true&arr6=true&samedep=true&samearr=true&minHourStay=0%3A45&maxHourStay=23%3A20&minHourOutbound=0%3A00&maxHourOutbound=24%3A00&minHourInbound=0%3A00&maxHourInbound=24%3A00&autoprice=true&adults=1&children=0&infants=0&maxChng=1&currency=EUR&indexSubmit=Search")
all <- html_text(html_nodes(loty, "p")) #cos z list_of_variables
loty <- read_html("http://www.azair.eu/azfin.php?tp=0&searchtype=flexi&srcAirport=Denmark+%5BAAR%5D+%28%2BAAL%2CBLL%2CCPH%29&srcTypedText=Den&srcFreeTypedText=&srcMC=DK&srcap0=AAL&srcap1=BLL&srcap2=CPH&srcFreeAirport=&dstAirport=London+%5BLGW%5D+%28%2BLHR%2CLCY%2CSEN%2CLTN%2CSTN%29&dstTypedText=Lon&dstFreeTypedText=&dstMC=LON_ALL&adults=1&children=0&infants=0&minHourStay=0%3A45&maxHourStay=23%3A20&minHourOutbound=0%3A00&maxHourOutbound=24%3A00&minHourInbound=0%3A00&maxHourInbound=24%3A00&dstap0=LHR&dstap1=LCY&dstap2=SEN&dstap3=LTN&dstap5=STN&dstFreeAirport=&depdate=23.4.2019&arrdate=31.3.2020&minDaysStay=5&maxDaysStay=8&nextday=0&autoprice=true&currency=EUR&wizzxclub=false&supervolotea=false&schengen=false&transfer=false&samedep=true&samearr=true&dep0=true&dep1=true&dep2=true&dep3=true&dep4=true&dep5=true&dep6=true&arr0=true&arr1=true&arr2=true&arr3=true&arr4=true&arr5=true&arr6=true&maxChng=1&isOneway=return&resultSubmit=Search")
all <- html_text(html_nodes(loty, "p")) #cos z list_of_variables
l <- strsplit(all[1], " ")
l <- unlist(l)
l <- l[(l != "") & (l != "\n")]
l
d <- data.frame()
d <- rbind(l)
d <- as.data.frame(d)
d <-d[c(-2, -3)]
d
all[1]
loty <- read_html("http://www.azair.eu/azfin.php?tp=0&searchtype=flexi&srcAirport=Denmark+%5BAAR%5D+%28%2BAAL%2CBLL%2CCPH%29&srcTypedText=Den&srcFreeTypedText=&srcMC=DK&srcap0=AAL&srcap1=BLL&srcap2=CPH&srcFreeAirport=&dstAirport=New+York+%28JFK%29+%5BJFK%5D&dstTypedText=New+York&dstFreeTypedText=&dstMC=&adults=1&children=0&infants=0&minHourStay=0%3A45&maxHourStay=23%3A20&minHourOutbound=0%3A00&maxHourOutbound=24%3A00&minHourInbound=0%3A00&maxHourInbound=24%3A00&dstFreeAirport=&depdate=23.4.2019&arrdate=31.3.2020&minDaysStay=5&maxDaysStay=8&nextday=0&autoprice=true&currency=EUR&wizzxclub=false&supervolotea=false&schengen=false&transfer=false&samedep=true&samearr=true&dep0=true&dep1=true&dep2=true&dep3=true&dep4=true&dep5=true&dep6=true&arr0=true&arr1=true&arr2=true&arr3=true&arr4=true&arr5=true&arr6=true&maxChng=1&isOneway=return&resultSubmit=Search")
all <- html_text(html_nodes(loty, "p")) #cos z list_of_variables
l <- strsplit(all[1], " ")
l <- unlist(l)
l <- l[(l != "") & (l != "\n")]
l
d <- data.frame()
d <- rbind(l)
d <- as.data.frame(d)
d <-d[c(-2, -3)]
d
# Podgląd elementów
all[1]
devtools::install_github("STATWORX/bounceR")
install.packages("devtools")
devtools::install_github("STATWORX/bounceR")
install.packages("devtools")
install.packages("devtools")
library(devtools)
library(devtools)
devtools::install_github("STATWORX/bounceR")
pi
n=1000
p=2
#Schemat 1:
x = matrix(0,nrow=n,ncol=p)
y = rbinom(n,1,0.5)
w1 = which(y==1)
w0 = which(y==0)
for(j in 1:p){
x[w1,j] = rnorm(length(w1),1,1)
}
for(j in 1:p){
x[w0,j] = rnorm(length(w0),0,1)
}
data = data.frame(x,y)
head(dat)
head(data)
model1 = lda(y~.,data=data)
pred1 = predict(model1,data,type=)
# Macierz klasyfikacji:
tab1 = table(y,pred1$class)
print(tab1)
cat("Accuracy for LDA =",sum(diag(tab1))/sum(tab1))
library(MASS)
model1 = lda(y~.,data=data)
pred1 = predict(model1,data,type=)
# Macierz klasyfikacji:
tab1 = table(y,pred1$class)
print(tab1)
cat("Accuracy for LDA =",sum(diag(tab1))/sum(tab1))
model2 = qda(y~.,data=data)
pred2 = predict(model2,data,type=)
# Macierz klasyfikacji:
tab2 = table(y,pred2$class)
print(tab2)
cat("Accuracy for QDA =",sum(diag(tab2))/sum(tab2))
matrix(c(1,0.8,0.8,1),ncol=2,nrow=2)
x = matrix(0,nrow=n,ncol=p)
y = rbinom(n,1,0.5)
w1 = which(y==1)
w0 = which(y==0)
Sigma0 = matrix(c(1,0.8,0.8,1),ncol=2,nrow=2)
x[w0,] = mvrnorm(n = length(w0), mu=c(0,0), Sigma=Sigma0)
?mvrnorm
matrix(c(10,3,3,2),2,2)
x
Sigma1 = matrix(c(1,-0.8,-0.8,1),ncol=2,nrow=2)
x[w1,] = mvrnorm(n = length(w1), mu=c(1,1), Sigma=Sigma1)
data = data.frame(x,y)
data
model1 = lda(y~.,data=data)
pred1 = predict(model1,data,type=)
# Macierz klasyfikacji:
tab1 = table(y,pred1$class)
print(tab1)
cat("Accuracy for LDA =",sum(diag(tab1))/sum(tab1))
model2 = qda(y~.,data=data)
pred2 = predict(model2,data,type=)
# Macierz klasyfikacji:
tab2 = table(y,pred2$class)
print(tab2)
cat("Accuracy for QDA =",sum(diag(tab2))/sum(tab2))
rm(list = ls())
Wina <- read.table("http://www.ipipan.eu/~teisseyrep/TEACHING/DM/DANE/wine.data", sep = ",")
Wina$V1 <- as.factor(Wina$V1)
library(MASS)
library(ggplot2)
w <- sample(1:nrow(Wina), size = ceiling(2/3*nrow(Wina)))
train <- Wina[w,]
test <- Wina[-w,]
#Dopasowanie modeli na danych treningowych:
# LDA
train.lda <- lda(V1 ~ V2 + V8, data = train)
# QDA
train.qda <- qda(V1 ~ V2 + V8, data = train)
#Wczytanie danych:
Wina <- read.table("https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data", sep = ",")
head(wina)
head(Wina)
Wina_names <- read.table("https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.names", sep = ',')
Wina_names <- read.table("https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.names")
Wina <- read.table("https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv", sep = ",")
Wina$V1 <- as.factor(Wina$V1)
library(MASS)
library(ggplot2)
w <- sample(1:nrow(Wina), size = ceiling(2/3*nrow(Wina)))
train <- Wina[w,]
test <- Wina[-w,]
#Dopasowanie modeli na danych treningowych:
# LDA
train.lda <- lda(V1 ~ V2 + V8, data = train)
# QDA
train.qda <- qda(V1 ~ V2 + V8, data = train)
Wina <- read.table("https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data", sep = ",")
Wina$V1 <- as.factor(Wina$V1)
library(MASS)
library(ggplot2)
w <- sample(1:nrow(Wina), size = ceiling(2/3*nrow(Wina)))
train <- Wina[w,]
test <- Wina[-w,]
#Dopasowanie modeli na danych treningowych:
# LDA
train.lda <- lda(V1 ~ V2 + V8, data = train)
# QDA
train.qda <- qda(V1 ~ V2 + V8, data = train)
ile <- 120 # parametr okreslajacy gestosc siatki punktow
xp <- seq(11, 15, length = ile)
yp <- seq(0.5, 5, length = ile)
siatka <- expand.grid(V2 = xp, V8 = yp)
z11 <- predict(train.lda, newdata = siatka)
head(z11$posterior)
# zp1 - pstwo aposteriori klasy 1 - max(pstwo aposteriori z klas 2 i 3)
# zp1 > 0 - klasyfikuj do grupy 1.
zp1 <- z11$post[, 1] - pmax(z11$post[, 2], z11$post[, 3])
zp2 <- z11$post[, 2] - pmax(z11$post[, 1], z11$post[, 3])
zp3 <- z11$post[, 3] - pmax(z11$post[, 1], z11$post[, 2])
plot(Wina[, c(2, 8)], type = "n", xlab = "Alcohol", ylab = "Flavanoids",
main = "LDA Classification")
text(Wina$V2, Wina$V8, as.character(Wina$V1), cex = 0.8)
# dorysujemy poziomice odpowiadajaca wartosci 0 dla zmiennych zp1, zp2, zp3 - sa
# to 'granice' przynaleznosci klasowej wyznaczone na podstawie metody LDA
contour(xp, yp, matrix(zp1, ile), level = 0, add = T, col = "red")
contour(xp, yp, matrix(zp2, ile), level = 0, add = T, col = "green")
contour(xp, yp, matrix(zp3, ile), level = 0, add = T, col = "blue")
q <- ggplot() +
geom_contour(data = cbind(siatka, data.frame(pred2 = zp2)),
aes(x = V2, y = V8, z = pred2), bins = 1, col = "green",
linetype = 1, size = 1.2, alpha = 0.5) +
geom_contour(data = cbind(siatka, data.frame(pred3 = zp3)),
aes(x = V2, y = V8, z = pred3), bins = 1, col = "blue",
linetype = 2, size = 1.2) +
geom_contour(data = cbind(siatka, data.frame(pred1 = zp1)),
aes(x = V2, y = V8, z = pred1), bins = 1, col = "red",
linetype = 4, size = 1.2) +
geom_point(data = Wina, aes(x = V2, y = V8, col = V1), size = 2) +
xlab("Alcohol") + ylab("Flavanoids") + ggtitle("LDA Classification") +
theme(plot.title = element_text(lineheight  = .8, face = "bold", hjust = 0.5)) +
theme(axis.title.x = element_text(size = 15, angle = 0, face = "italic"),
axis.title.y = element_text(size = 15, angle = 90, face = "italic")) +
theme(legend.title = element_text(size = 14, face = "bold")) +
theme(legend.text = element_text(colour = "black", size = 12)) +
guides(color = guide_legend(keywidth = 2, keyheight = 2))
q
z11 <- predict(train.qda, newdata = siatka)
head(z11$posterior)
#zp1 - pstwo aposteriori klasy 1 - max(pstwo aposteriori z klas 2 i 3)
#zp1 > 0 - klasyfikuj do grupy 1.
zp1 <- z11$post[, 1] - pmax(z11$post[, 2], z11$post[, 3])
zp2 <- z11$post[, 2] - pmax(z11$post[, 1], z11$post[, 3])
zp3 <- z11$post[, 3] - pmax(z11$post[, 1], z11$post[, 2])
plot(Wina[, c(2, 8)], type = "n", xlab = "Alcohol", ylab = "Flavanoids", main = "LDA Classification")
text(Wina$V2, Wina$V8, as.character(Wina$V1), cex = 0.8)
# dorysujemy poziomice odpowiadajaca wartosci 0 dla zmiennych zp1, zp2, zp3 - sa
# to 'granice' przynaleznosci klasowej wyznaczone na podstawie metody QDA
contour(xp, yp, matrix(zp1, ile), level = 0, add = T, col = "red")
contour(xp, yp, matrix(zp2, ile), level = 0, add = T, col = "green")
contour(xp, yp, matrix(zp3, ile), level = 0, add = T, col = "blue")
q <- ggplot() +
geom_contour(data = cbind(siatka, data.frame(pred2 = zp2)),
aes(x = V2, y = V8, z = pred2), bins = 1, col = "green",
linetype = 1, size = 1.2, alpha = 0.5) +
geom_contour(data = cbind(siatka, data.frame(pred3 = zp3)),
aes(x = V2, y = V8, z = pred3), bins = 1, col = "blue",
linetype = 2, size = 1.2) +
geom_contour(data = cbind(siatka, data.frame(pred1 = zp1)),
aes(x = V2, y = V8, z = pred1), bins = 1, col = "red",
linetype = 4, size = 1.2) +
geom_point(data = Wina, aes(x = V2, y = V8, col = V1), size = 2) +
xlab("Alcohol") + ylab("Flavanoids") + ggtitle("QDA Classification") +
theme(plot.title = element_text(lineheight  = .8, face = "bold", hjust = 0.5)) +
theme(axis.title.x = element_text(size = 15, angle = 0, face = "italic"),
axis.title.y = element_text(size = 15, angle = 90, face = "italic")) +
theme(legend.title = element_text(size = 14, face = "bold")) +
theme(legend.text = element_text(colour = "black", size = 12)) +
guides(color = guide_legend(keywidth = 2, keyheight = 2))
q
###### ZADANIE 4 #######
library(klaR)
#Wczytanie danych:
Kredit <- read.table("http://www.ipipan.eu/~teisseyrep/TEACHING/DM/DANE/kredit.asc", h = T)
cbind(siatka, data.frame(pred2 = zp2))
?geom_contour
q <- ggplot() +
geom_contour(data = cbind(siatka, data.frame(pred2 = zp2)),
aes(x = V2, y = V8, z = pred2), bins = 1, col = "green",
linetype = 1, size = 1.2, alpha = 0.5) +
geom_contour(data = cbind(siatka, data.frame(pred3 = zp3)),
aes(x = V2, y = V8, z = pred3), bins = 1, col = "blue",
linetype = 2, size = 1.2) +
geom_contour(data = cbind(siatka, data.frame(pred1 = zp1)),
aes(x = V2, y = V8, z = pred1), bins = 1, col = "red",
linetype = 4, size = 1.2) +
geom_point(data = Wina, aes(x = V2, y = V8, col = V1), size = 2)
q
?geom_contour
q <- ggplot() +
geom_contour(data = cbind(siatka, data.frame(pred2 = zp2)),
aes(x = V2, y = V8, z = pred2), bins = 2, col = "green",
linetype = 1, size = 1.2, alpha = 0.5) +
geom_contour(data = cbind(siatka, data.frame(pred3 = zp3)),
aes(x = V2, y = V8, z = pred3), bins = 2, col = "blue",
linetype = 2, size = 1.2) +
geom_contour(data = cbind(siatka, data.frame(pred1 = zp1)),
aes(x = V2, y = V8, z = pred1), bins = 2, col = "red",
linetype = 4, size = 1.2) +
geom_point(data = Wina, aes(x = V2, y = V8, col = V1), size = 2)
q
?pmax
z11$post[, 1]
pmax(z11$post[, 2], z11$post[, 3])
set_division <- function(data, train_frac) {
samp <- sample(nrow(data), nrow(data) * train_frac)
train <- data[samp, ]
test <- data[-samp, ]
return( list(train, test) )
}
data <- read.table("https://home.ipipan.waw.pl/p.teisseyre/TEACHING/ZMUM/DANE/SAheart.data")
data <- read.table("https://home.ipipan.waw.pl/p.teisseyre/TEACHING/ZMUM/DANE/SAheart.data", sep = ',')
rm(list = ls())
data <- read.table("https://home.ipipan.waw.pl/p.teisseyre/TEACHING/ZMUM/DANE/SAheart.data", sep = ',')
head(data)
data <- read.table("https://home.ipipan.waw.pl/p.teisseyre/TEACHING/ZMUM/DANE/SAheart.data", sep = ',', header = TRUE)
head(data)
SA.logit <- glm(chd ~. , data = data, family = 'binomial')
summary(SA.logit)
data <- read.table("https://home.ipipan.waw.pl/p.teisseyre/TEACHING/ZMUM/DANE/SAheart.data", sep = ',', header = TRUE, row.names = FALSE)
data <- read.table("https://home.ipipan.waw.pl/p.teisseyre/TEACHING/ZMUM/DANE/SAheart.data", sep = ',', header = TRUE)
data <- data[ , -1 ]
head(data)
SA.logit <- glm(chd ~. , data = data, family = 'binomial')
summary(SA.logit)
# dopasowany model regresji logistycznej
SA.logit <- glm(chd ~. , data = data, family = 'binomial')
# Podsumowanie, ktore wyswietla m.in. istotnosc zmiennych w modelu
# Mala p-wartosc oznacza, ze zmienna jest modelu istotna
# Innymi slowy, oznacza to ze jest małe prawdopodobienstwo, ze zaleznosc wyniku modelu nie zalezy od
# danej zmiennej
summary(SA.logit)
rm(list =)
rm(list =ls())
iris
data <- iris
# zostawiam tylko dwie klasy
data[!"Species" == "versicolor", ]
# zostawiam tylko dwie klasy
data["Species" != "versicolor", ]
# zostawiam tylko dwie klasy
data["Species" != "versicolor", ]
# zostawiam tylko dwie klasy
data[Species != "versicolor", ]
# zostawiam tylko dwie klasy
data[data$Species != "versicolor", ]
# zostawiam tylko dwie klasy
data <- data[data$Species != "versicolor", ]
#rm(list = ls())
library(ggplot2)
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, fill = Species)) + geom_point()
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length) fill = Species) + geom_point()
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length), fill = Species) + geom_point()
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = Species)) + geom_point()
data$Species <- ifelse(data$Species == "setosa", 0, 1)
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = Species)) + geom_point()
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, fill = Species)) + geom_point()
head(data)
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
data
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "versicolor", ]
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "versicolor", ]
data$Species <- as.factor(data$Species)
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
data <- iris
data$Species <- as.factor(data$Species)
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "setosa", ]
data$Species <- ifelse(data$Species == "setosa", 0, 1)
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "setosa", ]
data$Species <- ifelse(data$Species == "virginica", 0, 1)
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "setosa", ]
data$Species <- as.factor(data$Species)
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "setosa", ]
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
# zostawiam tylko dwie klasy
data <- data[data$Species != "virginica", ]
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "virginica", ]
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
summary(iris.glm)
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "setosa", ]
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
summary(iris.glm)
# zostawiam tylko dwie klasy
data <- data[data$Species != "versicolor", ]
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "versicolor", ]
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = as.factor(Species))) + geom_point()
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = Species)) + geom_point()
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
summary(iris.glm)
data <- iris
# zostawiam tylko dwie klasy
data <- data[data$Species != "setosa", ]
ggplot(data = data, aes(x = Sepal.Length, y = Petal.Length, color = Species)) + geom_point()
iris.glm <- glm(Species ~. , data = data, family = 'binomial')
summary(iris.glm)
iris.glm$coefficients
iris.glm$linear.predictors
iris.glm$fitted.values
iris.glm$linear.predictors == exp(iris.glm$fitted.values)
iris.glm$linear.predictors == log(iris.glm$fitted.values)
iris.glm$linear.predictors
iris.glm$fitted.values
log(iris.glm$linear.predictors)
log(iris.glm$linear.predictors / (1 - iris.glm$linear.predictors))
exp(iris.glm$linear.predictors) / (1 + exp(iris.glm$linear.predictors))
iris.glm$fitted.values
exp(iris.glm$linear.predictors) / (1 + exp(iris.glm$linear.predictors)) == iris.glm$fitted.values
?cut
createSeries <- function(n = 100, mu = 0, std = 5) {
time <- rnorm(n, mu, std)
x <- rnorm(n, 0, 1)
x <- cumsum(x)
return(data.frame(time, x))
}
createSeries(10)
createSeries <- function(n = 100, mu = 0, std = 5) {
time <- rnorm(n, mu, std)
x <- rnorm(n, 0, 1)
x <- cumsum(x)
dat <- data.frame(time, x)
dat <- dat[order(dat$time), ]
return(dat)
}
createSeries(10)
createSeries <- function(n = 100, mu = 0, std = 5) {
time <- rnorm(n, mu, std)
time <- sort(time, decreasing = FALSE)
x <- rnorm(n, 0, 1)
x <- cumsum(x)
return(data.frame(time, x))
}
createSeries(10)
dat <- createSeries(10)
cut(dat$time, breaks = seq(0, 10))
cut(dat, breaks = seq(0, 10))
exp(4)
exp(5)
exp(6)
exp(7)
exp(8)
exp(9)
exp(10)
setwd("C:/Users/piotr/Desktop/Github- projects/Machine-Learning/Laboratoria ZMUM/Logistic Regression")
dane <- read.table("../data/earthquake.txt", h = T)
###### ZADANIE 2 #######
library(ggplot2)
#Wykres:
ggplot(data = dane, aes(x = body, y = surface, col = popn))+
geom_point(size = 2.5) +
theme(axis.title.x = element_text(size = 15, angle = 0, face = "italic"),
axis.title.y = element_text(size = 15, angle = 90, face = "italic")) +
theme(legend.title = element_text(size = 14, face = "bold")) +
theme(legend.text = element_text(colour = "black", size = 12)) +
guides(color = guide_legend(keywidth = 2, keyheight = 2))
model <- glm(popn ~ ., data = dane, family = "binomial")
summary(model)
rm(list = ls())
library(ggplot2)
library(dplyr)
dat <- read.table('../data/earthquake.txt', header = TRUE)
plt <- dat %>% mutate(cl = ifelse(dat$popn == 'equake', 'Q', 'X')) %>% ggplot(aes(x = body, y = surface, color = popn, label = cl)) +
geom_text(aes(label = cl))
plt
head(dat)
#dat$popn <- ifelse(dat$popn == 'equake', 1, 0)
tree <-  rpart(formula = as.factor(popn) ~ body + surface, data = dat,
control = rpart.control(minsplit = 15))
summary(tree)
rpart.plot(tree)
library(rpart)
library(rpart.plot)
library(ggplot2)
library(dplyr)
rm(list = ls())
library(ggplot2)
library(dplyr)
dat <- read.table('../data/earthquake.txt', header = TRUE)
plt <- dat %>% mutate(cl = ifelse(dat$popn == 'equake', 'Q', 'X')) %>% ggplot(aes(x = body, y = surface, color = popn, label = cl)) +
geom_text(aes(label = cl))
plt
head(dat)
#dat$popn <- ifelse(dat$popn == 'equake', 1, 0)
tree <-  rpart(formula = as.factor(popn) ~ body + surface, data = dat,
control = rpart.control(minsplit = 15))
summary(tree)
rpart.plot(tree)
head(dat)
tree.grid = expand.grid(
body = seq(min(dat$body), max(dat$body), length = 50),
surface = seq(min(dat$surface), max(dat$surface), length = 50)
)
pred = predict(tree, newdata = tree.grid, type = 'prob')
tree
# To jest po to, ze de facto rysujemy kontur w 3d i to co jest na wykresie to przeciecie tego konturu z plaszczyzna z = 0
zpred <- ifelse(pred[,1] == 1, 1, -1)
ggplot() +
geom_contour(data = cbind(tree.grid, zpred), aes(x = body, y = surface, z = zpred), bins = 1) +
geom_point(data = dat, aes(x = body, y =surface))
dat <- read.table('../data/earthquake.txt', header = TRUE)
plt <- dat %>% mutate(cl = ifelse(dat$popn == 'equake', 'Q', 'X')) %>% ggplot(aes(x = body, y = surface, color = popn, label = cl)) +
geom_text(aes(label = cl))
plt
head(dat)
#dat$popn <- ifelse(dat$popn == 'equake', 1, 0)
tree <-  rpart(formula = as.factor(popn) ~ body + surface, data = dat,
control = rpart.control(minsplit = 5))
summary(tree)
rpart.plot(tree)
# Tutaj robimy jak (chyba regresji logistycznej)
#siatka
head(dat)
tree.grid = expand.grid(
body = seq(min(dat$body), max(dat$body), length = 50),
surface = seq(min(dat$surface), max(dat$surface), length = 50)
)
pred = predict(tree, newdata = tree.grid, type = 'prob')
tree
# To jest po to, ze de facto rysujemy kontur w 3d i to co jest na wykresie to przeciecie tego konturu z plaszczyzna z = 0
zpred <- ifelse(pred[,1] == 1, 1, -1)
ggplot() +
geom_contour(data = cbind(tree.grid, zpred), aes(x = body, y = surface, z = zpred), bins = 1) +
geom_point(data = dat, aes(x = body, y =surface))
